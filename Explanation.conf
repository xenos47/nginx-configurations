###### Файл конфигурации Nginx nginx.conf Китайское подробное объяснение #####

 # Определить пользователей и группы пользователей, которые запускает Nginx
user www www;

 #nginx Количество процессов, рекомендуется установить его равным общему количеству ядер ЦП.
worker_processes 8;

 # Глобальный тип определения журнала ошибок, [отладка | информация | уведомление | предупреждение | ошибка | крит]
error_log /usr/local/nginx/logs/error.log info;

 # Процесс pid файл
pid /usr/local/nginx/logs/nginx.pid;

 # Укажите максимальное количество дескрипторов, которые может открыть процесс: число
 # Рабочий режим и максимальное количество соединений
 # Эта инструкция относится к максимальному количеству файловых дескрипторов, открытых процессом nginx.Теоретическое значение должно быть максимальным количеством открытых файлов (ulimit -n), деленным на количество процессов nginx, но запрос выделения nginx не такой равномерный, поэтому лучше всего Значение ulimit -n остается неизменным.
 # Теперь количество открытых файлов в ядре Linux 2.6 равно 65535, а worker_rlimit_nofile должен быть соответственно 65535.
 # Это связано с тем, что при назначении nginx запрос на распределение для процесса не так сбалансирован, поэтому при заполнении 10240 процесс может превысить 10240, когда общий параллелизм достигает 3-4 миллионов, и возвращается ошибка 502.
worker_rlimit_nofile 65535;


events
{
         # Ссылочная модель события, используйте [kqueue | rtsig | epoll | / dev / poll | select | poll]; модель epoll
         # Является высокопроизводительной моделью сетевого ввода-вывода в ядре Linux 2.6 и выше. Linux рекомендует epoll. При работе на FreeBSD используйте модель kqueue.
         # Дополнительное примечание:
         # Подобно apache, nginx имеет разные модели событий для разных операционных систем
         #A) Стандартная модель события
         # Select 、 poll относится к стандартной модели событий.Если в текущей системе нет более эффективного метода, nginx выберет select или poll
         #B) Эффективная модель события
         #Kqueue: Используется в FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 и MacOS X. Использование двухпроцессорных систем MacOS X с использованием kqueue может вызвать сбой ядра.
         #Epoll: используется в ядре Linux версии 2.6 и новее.
         # / dev / poll: используется в Solaris 7 11/99 +, HP / UX 11.22+ (EventPort), IRIX 6.5.15+ и Tru64 UNIX 5.1A +.
         #Eventport: используется в Solaris 10. Чтобы предотвратить сбои ядра, необходимо установить исправления безопасности.
    use epoll;

         # Максимальное количество соединений для одного процесса (максимальное количество соединений = количество соединений * количество процессов)
         # В соответствии с настройкой оборудования, используйте его в сочетании с предыдущим рабочим процессом, насколько это возможно, но не загружайте процессор до 100%. Максимальное количество соединений, разрешенных каждым процессом. Теоретически, максимальное количество соединений на сервер nginx равно.
    worker_connections 65535;

         #keepalivetime time.
    keepalive_timeout 60;

         # Размер буфера заголовка запроса клиента. Это может быть установлено в соответствии с размером подкачки вашей системы.Как правило, размер заголовка запроса не превышает 1 КБ, но, поскольку общая страница подкачки больше 1 КБ, здесь устанавливается размер подкачки.
         # Размер страницы можно получить с помощью команды getconf PAGESIZE.
    #[root@web001 ~]# getconf PAGESIZE
    #4096
         # Но есть случаи, когда client_header_buffer_size превышает 4k, но значение client_header_buffer_size должно быть установлено в целое кратное «системного размера страницы».
    client_header_buffer_size 4k;

         # Это будет указывать кэш для открытых файлов, который по умолчанию не включен, max указывает количество кешей, рекомендуется соответствовать количеству открытых файлов, неактивным - через сколько времени после того, как файл не был запрошен, кеш удаляется.
    open_file_cache max=65535 inactive=60s;

         # Это как часто проверять кеш на достоверность информации.
         #Syntax: open_file_cache_valid time По умолчанию: open_file_cache_valid 60 Используемые поля: http, server, location Эта директива указывает, когда проверять действительную информацию о кэшированных элементах в open_file_cache.
    open_file_cache_valid 80s;

         #open_file_cache Неактивный параметр файла в течение минимального количества раз. Если это число превышено, дескриптор файла всегда открывается в кэше. удален.
         #Syntax: open_file_cache_min_uses number Значение по умолчанию: open_file_cache_min_uses 1 Используемые поля: http, server, location Эта директива указывает минимальное количество файлов, которые можно использовать в пределах определенного временного диапазона среди недопустимых параметров директивы open_file_cache. Если используется большее значение, описание файла Символы всегда включены в кеш.
    open_file_cache_min_uses 1;

    #Syntax: open_file_cache_errors on | off По умолчанию: open_file_cache_errors off Используемые поля: http, server, location Эта директива указывает, следует ли искать файл для регистрации ошибок кэша.
    open_file_cache_errors on;
}



 # Настройте http-сервер и используйте его функцию обратного прокси для обеспечения поддержки балансировки нагрузки.
http
{
         # Расширение файла и таблица соответствия типов файлов
    include mime.types;

         # Тип файла по умолчанию
    default_type application/octet-stream;

         # Кодировка по умолчанию
    #charset utf-8;

         # Размер хеш-таблицы имени сервера
         # Хеш-таблица для сохранения имен серверов контролируется инструкциями server_names_hash_max_size и server_names_hash_bucket_size. Размер хеш-памяти параметра всегда равен размеру хеш-таблицы и кратен размеру кэша процессора. После уменьшения количества обращений к памяти становится возможным ускорить поиск значений ключей хеш-таблицы в процессоре. Если размер хеш-памяти равен размеру кэша процессора, то в худшем случае число поисков в памяти равно 2. Первый раз - определить адрес блока хранения, а второй раз - найти значение ключа в блоке хранения. Поэтому, если Nginx дает подсказку о том, что необходимо увеличить максимальный размер хеша или размер сегмента хеша, в первую очередь необходимо увеличить размер предыдущего параметра.
    server_names_hash_bucket_size 128;

         # Размер буфера заголовка запроса клиента. Это может быть установлено в соответствии с размером подкачки вашей системы.Как правило, размер заголовка запроса не превышает 1 КБ, но, поскольку общая страница подкачки больше, чем 1 КБ, здесь устанавливается размер подкачки. Размер страницы можно получить с помощью команды getconf PAGESIZE.
    client_header_buffer_size 32k;

         # Размер буфера заголовка запроса клиента. По умолчанию nginx будет использовать буфер client_header_buffer_size для чтения значения заголовка. Если заголовок слишком велик, он будет использовать large_client_header_buffers для его чтения.
    large_client_header_buffers 4 64k;

         # Установить размер файла, загруженного nginx
    client_max_body_size 8m;

         # Включить эффективный режим передачи файлов. Инструкция sendfile указывает, будет ли nginx вызывать функцию sendfile для вывода файла. Включите его для общих приложений. Если он используется для загрузки и других приложений с высокой нагрузкой на диске приложений, отключите его, чтобы сбалансировать диск и сеть. / O скорость обработки, снижающая нагрузку на систему. Примечание. Если изображение не отображается должным образом, отключите его.
         Директива #sendfile указывает, будет ли nginx вызывать функцию sendfile (метод нулевого копирования) для вывода файла. Для обычных приложений она должна быть включена. Если он используется для приложений ввода-вывода с высокой нагрузкой, таких как загрузка, вы можете отключить его, чтобы сбалансировать скорость обработки диска и сетевого ввода-вывода и сократить время работы системы.
    sendfile on;

         # Включить доступ к списку каталогов, подходящий сервер загрузки, по умолчанию закрыт.
    autoindex on;

         # Эта опция разрешает или запрещает использование опции socks TCP_CORK, эта опция используется только при использовании sendfile
    tcp_nopush on;

    tcp_nodelay on;

         Время ожидания соединения #, секунда
    keepalive_timeout 120;

         Параметры #FastCGI предназначены для повышения производительности сайта: снижения потребления ресурсов и увеличения скорости доступа. Следующие параметры могут быть поняты буквально.
    fastcgi_connect_timeout 300;
    fastcgi_send_timeout 300;
    fastcgi_read_timeout 300;
    fastcgi_buffer_size 64k;
    fastcgi_buffers 4 64k;
    fastcgi_busy_buffers_size 128k;
    fastcgi_temp_file_write_size 128k;

         #gzipmodule settings
         gzip on; # Включить сжатый вывод gzip
         gzip_min_length 1k; # Минимальный размер сжатого файла
         gzip_buffers 4 16k; # сжатые буферы
         gzip_http_version 1.0; # сжатая версия (по умолчанию 1.1, если интерфейс Squid2.5, пожалуйста, используйте 1.0)
         gzip_comp_level 2; # Уровень сжатия
         gzip_types text / plain application / x-javascript text / css application / xml; # Тип сжатия, который по умолчанию уже содержит textml, поэтому нет необходимости писать его ниже, не будет проблем при его написании, но будет предупреждение.
    gzip_vary on;

         # Требуется при включении ограничения количества IP-соединений
    #limit_zone crawler $binary_remote_addr 10m;



         # Конфигурация балансировки загрузки
    upstream piao.jd.com {

                 # перед балансировкой нагрузки, вес - это вес, который можно определить в соответствии с конфигурацией машины. Параметр weigth указывает значение веса, и чем выше значение веса, тем больше вероятность его назначения.
        server 192.168.80.121:80 weight=3;
        server 192.168.80.122:80 weight=2;
        server 192.168.80.123:80 weight=3;

                 В настоящее время # nginx поддерживает 4 способа распространения
                 # 1 Опрос (по умолчанию)
                 # Каждый запрос распределяется между различными внутренними серверами один за другим в хронологическом порядке. Если внутренний сервер не работает, он может быть автоматически удален.
        #2、weight
                 # Укажите вероятность опроса, вес пропорционален отношению доступа и используется в случае неравномерной производительности внутреннего сервера.
                 # Например:
        #upstream bakend {
        #    server 192.168.0.14 weight=10;
        #    server 192.168.0.15 weight=10;
        #}
        #2、ip_hash
                 # Каждый запрос распределяется в соответствии с результатом хеширования ip доступа, так что каждый посетитель имеет фиксированный доступ к внутреннему серверу, что может решить проблему сеанса.
                 # Например:
        #upstream bakend {
        #    ip_hash;
        #    server 192.168.0.14:88;
        #    server 192.168.0.15:80;
        #}
                 № 3, ярмарка (третья сторона)
        # Распределять запросы в соответствии с временем ответа внутреннего сервера и отдавать приоритет короткому времени ответа.
        #upstream backend {
        #    server server1;
        #    server server2;
        #    fair;
        #}
                 # 4, url_hash (третье лицо)
                 # Распределять запросы в соответствии с результатом хеширования доступного URL-адреса, чтобы каждый URL-адрес направлялся на один и тот же внутренний сервер, что более эффективно, когда внутренний сервер является кешем.
                 # Пример: добавить оператор хеша в восходящем потоке, и другие параметры, такие как weight, не могут быть записаны в оператор сервера, hash_method - используемый алгоритм хеширования
        #upstream backend {
        #    server squid1:3128;
        #    server squid2:3128;
        #    hash $request_uri;
        #    hash_method crc32;
        #}

        #tips:
                 #upstream bakend {# Определить IP-адрес и состояние устройства балансировки нагрузки} {
        #    ip_hash;
        #    server 127.0.0.1:9090 down;
        #    server 127.0.0.1:8080 weight=2;
        #    server 127.0.0.1:6060;
        #    server 127.0.0.1:7070 backup;
        #}
                 # Добавить proxy_pass http: // bakend / на сервере, который должен использовать балансировку нагрузки;

                 # Статус каждого устройства устанавливается на:
                 # 1.down означает, что сервер перед заказом временно не участвует в загрузке
                 # 2.вес больше, чем вес, тем больше вес груза.
                 # 3.max_fails: Количество допустимых сбоев запроса по умолчанию равно 1. При превышении максимального количества возвращается ошибка, определенная модулем proxy_next_upstream
                 # 4.fail_timeout: время паузы после сбоев max_fails.
                 Резервное копирование # 5.: Когда все другие не резервные машины не работают или заняты, запросите резервную машину. Так что эта машина будет самой легкой.

                 #nginx поддерживает настройку нескольких групп балансировки нагрузки одновременно, которые могут использоваться неиспользуемыми серверами.
                 Для #client_body_in_file_only установлено значение On Можно сказать, что данные из записи клиента записываются в файл для отладки.
                 #client_body_temp_path Установить каталог для записи файлов. Вы можете установить до 3 уровней каталогов.
                 #location Matchs URL. Может перенаправлять или выполнять новую балансировку нагрузки прокси
    }



         # Конфигурация виртуального хоста
    server
    {
                 # Порт прослушивания
        listen 80;

                 # Доменные имена могут иметь несколько разделенных пробелами
        server_name www.jd.com jd.com;
        index index.html index.htm index.php;
        root /data/www/jd;

                 # Балансировка загрузки на ****
        location ~ .*.(php|php5)?$
        {
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            include fastcgi.conf;
        }

                 # Настройки времени кеша изображения
        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$
        {
            expires 10d;
        }

                 #JS и CSS настройки времени кеширования
        location ~ .*.(js|css)?$
        {
            expires 1h;
        }

                 #LOG Настройки формата
                 # $ remote_addr и $ http_x_forwarded_for используются для записи IP-адреса клиента;
                 # $ remote_user: используется для записи имени пользователя клиента;
                 # $ time_local: используется для записи времени доступа и часового пояса;
                 # $ request: протокол URL и http, используемый для записи запроса;
                 # $ status: используется для записи статуса запроса; успех равен 200,
                 # $ body_bytes_sent: записать размер содержимого тела файла, отправляемого клиенту;
                 # $ http_referer: используется для записи посещений по ссылке на эту страницу;
                 # $ http_user_agent: записывать информацию о браузере клиента;
                 # Обычно веб-сервер размещается за обратным прокси-сервером, поэтому IP-адрес клиента не может быть получен. IP-адрес, полученный с помощью $ remote_add, является iP-адресом обратного прокси-сервера. Обратный прокси-сервер может добавить информацию x_forwarded_for к информации заголовка http перенаправленного запроса, чтобы записать IP-адрес исходного клиента и адрес сервера исходного запроса клиента.
        log_format access '$remote_addr - $remote_user [$time_local] "$request" '
        '$status $body_bytes_sent "$http_referer" '
        '"$http_user_agent" $http_x_forwarded_for';

                 # Определить журнал доступа этого виртуального хоста
        access_log  /usr/local/nginx/logs/host.access.log  main;
        access_log  /usr/local/nginx/logs/host.access.404.log  log404;

                 # Включить обратный прокси для "/"
        location / {
            proxy_pass http://127.0.0.1:88;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;

                         # Внутренний веб-сервер может получить реальный IP-адрес пользователя через X-Forwarded-For.
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

                         # Ниже приведены некоторые конфигурации обратного прокси, необязательно.
            proxy_set_header Host $host;

                         # Максимальное количество байтов одного файла, разрешенных клиентом
            client_max_body_size 10m;

                         #Buffer agent буферизует максимальное количество байтов, запрошенных клиентом,
                         # Если для него установлено относительно большое значение, например 256 КБ, то нормально отправлять любое изображение размером менее 256 КБ с помощью браузера Firefox или IE. Если вы прокомментируете эту инструкцию и используете стандартную настройку client_body_buffer_size, которая в два раза больше размера страницы операционной системы, 8 КБ или 16 КБ, проблема возникает.
                         # При использовании Firefox4.0 или IE8.0 при отправке относительно большого изображения размером 200 Кбайт возвращается 500 Internal Server Error
            client_body_buffer_size 128k;

                         # Означает, что nginx блокирует ответы с HTTP-кодом ответа 400 или выше.
            proxy_intercept_errors on;

                         # Соединение с внутренним сервером timeout_initiate рукопожатие и ожидание времени ожидания ответа
            #nginx Тайм-аут соединения с внутренним сервером (тайм-аут соединения с прокси)
            proxy_connect_timeout 90;

                         # Время возврата данных с сервера (время ожидания отправки агента)
                         # Backend server data return time_ означает, что внутренний сервер должен завершить передачу всех данных в течение указанного времени
            proxy_send_timeout 90;

                         # После успешного установления соединения время отклика внутреннего сервера (прокси получает тайм-аут)
                         #Connection     _Дождаться времени ответа внутреннего сервера. Фактически, он был помещен в очередь на внутреннем сервере и ожидает обработки (также можно сказать, что внутренний сервер обрабатывает запрос)
            proxy_read_timeout 90;

                         # Установить размер буфера прокси-сервера (nginx) для информации заголовка пользователя
                         # Установите размер буфера первой части ответа, считываемой с прокси-сервера. Обычно эта часть ответа содержит небольшой заголовок ответа. По умолчанию это значение размера буфера, указанного в инструкции proxy_buffers. Но это может быть сделано меньше
            proxy_buffer_size 4k;

                         #proxy_buffers buffer, средняя настройка веб-страниц ниже 32k
                         # Установите количество и размер буфера, используемого для чтения ответа (с прокси-сервера). По умолчанию также используется размер страницы. Он может быть 4 или 8 КБ, в зависимости от операционной системы.
            proxy_buffers 4 32k;

                         # Размер буфера при высокой нагрузке (proxy_buffers * 2)
            proxy_busy_buffers_size 64k;

                         # Устанавливать размер данных при записи в proxy_temp_path, чтобы рабочий процесс не блокировал слишком долго при передаче файлов
                         # Установите размер папки кеша, больше чем это значение, будет передаваться с вышестоящего сервера
            proxy_temp_file_write_size 64k;
        }


                 # Установить адрес для просмотра статуса Nginx
        location /NginxStatus {
            stub_status on;
            access_log on;
            auth_basic "NginxStatus";
            auth_basic_user_file confpasswd;
                         Содержимое файла #htpasswd может быть сгенерировано с помощью инструмента htpasswd, предоставляемого Apache.
        }

                 # Конфигурация обратного прокси с динамическим и статическим разделением
                 # Все страницы JSP обрабатываются Tomcat или смолой
        location ~ .(jsp|jspx|do)?$ {
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass http://127.0.0.1:8080;
        }

                 # Все статические файлы читаются напрямую nginx, не проходя через tomcat или смолу
        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|
        pdf|xls|mp3|wma)$
        {
            expires 15d;
        }

        location ~ .*.(js|css)?$
        {
            expires 1h;
        }
    }
}
 ###### Файл конфигурации Nginx nginx.conf Китайское подробное объяснение #####
